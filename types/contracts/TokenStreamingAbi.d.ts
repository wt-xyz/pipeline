/* Autogenerated file. Do not edit manually. */

/* eslint-disable */

/*
  Fuels version: 0.82.0
  Forc version: 0.49.3
  Fuel-Core version: 0.22.1
*/

import type {
  BigNumberish,
  BN,
  Bytes,
  BytesLike,
  Contract,
  DecodedValue,
  FunctionFragment,
  Interface,
  InvokeFunction,
  StdString,
} from "fuels";

import type { Option, Enum } from "./common";

export enum ErrorInput {
  NonExistentStream = "NonExistentStream",
  InvalidDates = "InvalidDates",
  DateTooEarly = "DateTooEarly",
  SelfAddress = "SelfAddress",
  ZeroAddress = "ZeroAddress",
  ZeroDeposit = "ZeroDeposit",
  StreamDoesNotExist = "StreamDoesNotExist",
  VaultDoesNotExist = "VaultDoesNotExist",
  NotReceiver = "NotReceiver",
  InsufficientBalance = "InsufficientBalance",
  InsufficientShares = "InsufficientShares",
  StreamAlreadyCancelled = "StreamAlreadyCancelled",
  NotSender = "NotSender",
  NotEnoughCoins = "NotEnoughCoins",
  DepositsBlocked = "DepositsBlocked",
  InvalidAsset = "InvalidAsset",
  IncorrectDeposit = "IncorrectDeposit",
  NotCancellable = "NotCancellable",
}
export enum ErrorOutput {
  NonExistentStream = "NonExistentStream",
  InvalidDates = "InvalidDates",
  DateTooEarly = "DateTooEarly",
  SelfAddress = "SelfAddress",
  ZeroAddress = "ZeroAddress",
  ZeroDeposit = "ZeroDeposit",
  StreamDoesNotExist = "StreamDoesNotExist",
  VaultDoesNotExist = "VaultDoesNotExist",
  NotReceiver = "NotReceiver",
  InsufficientBalance = "InsufficientBalance",
  InsufficientShares = "InsufficientShares",
  StreamAlreadyCancelled = "StreamAlreadyCancelled",
  NotSender = "NotSender",
  NotEnoughCoins = "NotEnoughCoins",
  DepositsBlocked = "DepositsBlocked",
  InvalidAsset = "InvalidAsset",
  IncorrectDeposit = "IncorrectDeposit",
  NotCancellable = "NotCancellable",
}
export type IdentityInput = Enum<{
  Address: AddressInput;
  ContractId: ContractIdInput;
}>;
export type IdentityOutput = Enum<{
  Address: AddressOutput;
  ContractId: ContractIdOutput;
}>;
export enum SenderOrReceiverInput {
  Sender = "Sender",
  Receiver = "Receiver",
}
export enum SenderOrReceiverOutput {
  Sender = "Sender",
  Receiver = "Receiver",
}

export type AddressInput = { value: string };
export type AddressOutput = AddressInput;
export type AssetIdInput = { value: string };
export type AssetIdOutput = AssetIdInput;
export type CancelStreamInput = {
  stream_id: BigNumberish;
  sender_asset: AssetIdInput;
  receiver_asset: AssetIdInput;
  unvested_recipient: IdentityInput;
  unvested_balance: BigNumberish;
  vested_balance: BigNumberish;
};
export type CancelStreamOutput = {
  stream_id: BN;
  sender_asset: AssetIdOutput;
  receiver_asset: AssetIdOutput;
  unvested_recipient: IdentityOutput;
  unvested_balance: BN;
  vested_balance: BN;
};
export type ContractIdInput = { value: string };
export type ContractIdOutput = ContractIdInput;
export type CreateStreamInput = {
  stream_id: BigNumberish;
  sender: IdentityInput;
  underlying_asset: AssetIdInput;
  receiver: IdentityInput;
  receiver_asset: AssetIdInput;
  sender_asset: AssetIdInput;
  deposit: BigNumberish;
  stream_size: BigNumberish;
  start_time: BigNumberish;
  stop_time: BigNumberish;
};
export type CreateStreamOutput = {
  stream_id: BN;
  sender: IdentityOutput;
  underlying_asset: AssetIdOutput;
  receiver: IdentityOutput;
  receiver_asset: AssetIdOutput;
  sender_asset: AssetIdOutput;
  deposit: BN;
  stream_size: BN;
  start_time: BN;
  stop_time: BN;
};
export type DepositInput = {
  caller: IdentityInput;
  receiver: IdentityInput;
  underlying_asset: AssetIdInput;
  vault_sub_id: string;
  deposited_amount: BigNumberish;
  minted_shares: BigNumberish;
};
export type DepositOutput = {
  caller: IdentityOutput;
  receiver: IdentityOutput;
  underlying_asset: AssetIdOutput;
  vault_sub_id: string;
  deposited_amount: BN;
  minted_shares: BN;
};
export type RawBytesInput = { ptr: BigNumberish; cap: BigNumberish };
export type RawBytesOutput = { ptr: BN; cap: BN };
export type StreamInput = {
  deposit: BigNumberish;
  rate_per_second_e_10: BigNumberish;
  stream_size: BigNumberish;
  vested_withdrawn_amount: BigNumberish;
  start_time: BigNumberish;
  stop_time: BigNumberish;
  underlying_asset: AssetIdInput;
  receiver_asset: AssetIdInput;
  sender_asset: AssetIdInput;
  cancellation_time: Option<BigNumberish>;
  configuration: StreamConfigurationInput;
};
export type StreamOutput = {
  deposit: BN;
  rate_per_second_e_10: BN;
  stream_size: BN;
  vested_withdrawn_amount: BN;
  start_time: BN;
  stop_time: BN;
  underlying_asset: AssetIdOutput;
  receiver_asset: AssetIdOutput;
  sender_asset: AssetIdOutput;
  cancellation_time: Option<BN>;
  configuration: StreamConfigurationOutput;
};
export type StreamConfigurationInput = {
  is_cancellable: boolean;
  is_undercollateralized: boolean;
};
export type StreamConfigurationOutput = StreamConfigurationInput;
export type VaultInfoInput = {
  vault_sub_id: string;
  asset: AssetIdInput;
  stream_id: BigNumberish;
  sender_or_receiver: SenderOrReceiverInput;
};
export type VaultInfoOutput = {
  vault_sub_id: string;
  asset: AssetIdOutput;
  stream_id: BN;
  sender_or_receiver: SenderOrReceiverOutput;
};
export type WithdrawInput = {
  caller: IdentityInput;
  receiver: IdentityInput;
  underlying_asset: AssetIdInput;
  vault_sub_id: string;
  withdrawn_amount: BigNumberish;
  burned_shares: BigNumberish;
};
export type WithdrawOutput = {
  caller: IdentityOutput;
  receiver: IdentityOutput;
  underlying_asset: AssetIdOutput;
  vault_sub_id: string;
  withdrawn_amount: BN;
  burned_shares: BN;
};

interface TokenStreamingAbiInterface extends Interface {
  functions: {
    cancel_stream: FunctionFragment;
    create_stream: FunctionFragment;
    get_stream: FunctionFragment;
    get_stream_by_vault_share_id: FunctionFragment;
    get_vault_info: FunctionFragment;
    is_solvent: FunctionFragment;
    partial_withdraw_from_stream: FunctionFragment;
    underlying_asset: FunctionFragment;
    vested_amount: FunctionFragment;
    decimals: FunctionFragment;
    name: FunctionFragment;
    symbol: FunctionFragment;
    total_assets: FunctionFragment;
    total_supply: FunctionFragment;
    deposit: FunctionFragment;
    managed_assets: FunctionFragment;
    max_depositable: FunctionFragment;
    max_withdrawable: FunctionFragment;
    withdraw: FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "cancel_stream",
    values: [IdentityInput],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "create_stream",
    values: [
      IdentityInput,
      IdentityInput,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      StreamConfigurationInput,
    ],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "get_stream",
    values: [BigNumberish],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "get_stream_by_vault_share_id",
    values: [AssetIdInput],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "get_vault_info",
    values: [AssetIdInput],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "is_solvent",
    values: [BigNumberish],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "partial_withdraw_from_stream",
    values: [IdentityInput, BigNumberish],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "underlying_asset",
    values: [AssetIdInput],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "vested_amount",
    values: [BigNumberish],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "decimals",
    values: [AssetIdInput],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "name",
    values: [AssetIdInput],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "symbol",
    values: [AssetIdInput],
  ): Uint8Array;
  encodeFunctionData(functionFragment: "total_assets", values: []): Uint8Array;
  encodeFunctionData(
    functionFragment: "total_supply",
    values: [AssetIdInput],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [IdentityInput, string],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "managed_assets",
    values: [AssetIdInput, string],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "max_depositable",
    values: [IdentityInput, AssetIdInput, string],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "max_withdrawable",
    values: [AssetIdInput, string],
  ): Uint8Array;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [IdentityInput, AssetIdInput, string],
  ): Uint8Array;

  decodeFunctionData(
    functionFragment: "cancel_stream",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "create_stream",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "get_stream",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "get_stream_by_vault_share_id",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "get_vault_info",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "is_solvent",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "partial_withdraw_from_stream",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "underlying_asset",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "vested_amount",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "decimals",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(functionFragment: "name", data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: "symbol", data: BytesLike): DecodedValue;
  decodeFunctionData(
    functionFragment: "total_assets",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "total_supply",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "deposit",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "managed_assets",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "max_depositable",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "max_withdrawable",
    data: BytesLike,
  ): DecodedValue;
  decodeFunctionData(
    functionFragment: "withdraw",
    data: BytesLike,
  ): DecodedValue;
}

export class TokenStreamingAbi extends Contract {
  interface: TokenStreamingAbiInterface;
  functions: {
    cancel_stream: InvokeFunction<[unvested_recipient: IdentityInput], BN>;
    create_stream: InvokeFunction<
      [
        sender_share_recipient: IdentityInput,
        receiver_share_recipient: IdentityInput,
        start_time: BigNumberish,
        stop_time: BigNumberish,
        stream_size: BigNumberish,
        configuration: StreamConfigurationInput,
      ],
      BN
    >;
    get_stream: InvokeFunction<[stream_id: BigNumberish], StreamOutput>;
    get_stream_by_vault_share_id: InvokeFunction<
      [vault_share_asset_id: AssetIdInput],
      [StreamOutput, BN]
    >;
    get_vault_info: InvokeFunction<
      [share_asset_id: AssetIdInput],
      VaultInfoOutput
    >;
    is_solvent: InvokeFunction<[stream_id: BigNumberish], boolean>;
    partial_withdraw_from_stream: InvokeFunction<
      [receiver: IdentityInput, amount: BigNumberish],
      BN
    >;
    underlying_asset: InvokeFunction<
      [vault_share_asset: AssetIdInput],
      AssetIdOutput
    >;
    vested_amount: InvokeFunction<[stream_id: BigNumberish], BN>;
    decimals: InvokeFunction<[_asset: AssetIdInput], Option<number>>;
    name: InvokeFunction<[asset: AssetIdInput], Option<StdString>>;
    symbol: InvokeFunction<[asset: AssetIdInput], Option<StdString>>;
    total_assets: InvokeFunction<[], BN>;
    total_supply: InvokeFunction<[asset: AssetIdInput], Option<BN>>;
    deposit: InvokeFunction<
      [receiver: IdentityInput, vault_sub_id: string],
      BN
    >;
    managed_assets: InvokeFunction<
      [_underlying_asset: AssetIdInput, vault_sub_id: string],
      BN
    >;
    max_depositable: InvokeFunction<
      [
        _receiver: IdentityInput,
        _underlying_asset: AssetIdInput,
        vault_sub_id: string,
      ],
      Option<BN>
    >;
    max_withdrawable: InvokeFunction<
      [_underlying_asset: AssetIdInput, vault_sub_id: string],
      Option<BN>
    >;
    withdraw: InvokeFunction<
      [
        receiver: IdentityInput,
        _underlying_asset: AssetIdInput,
        _vault_sub_id: string,
      ],
      BN
    >;
  };
}
